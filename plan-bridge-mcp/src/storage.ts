import { readFileSync, writeFileSync, mkdirSync, readdirSync, existsSync, rmSync } from "fs";
import { join } from "path";
import { homedir } from "os";
import type { Plan, PlanStatus, Phase } from "./types.js";

const GLOBAL_STORAGE_DIR = join(homedir(), ".plan-bridge", "plans");

/**
 * Determines the storage path for a plan based on its storage mode
 */
export function getStoragePath(plan: Plan): string {
  if (plan.storage_mode === "local") {
    return join(plan.project_path, ".plans", plan.id);
  }
  return GLOBAL_STORAGE_DIR;
}

/**
 * Ensures local storage directory exists for a plan
 */
export function ensureLocalStorage(projectPath: string, planId: string): void {
  const planDir = join(projectPath, ".plans", planId);
  mkdirSync(planDir, { recursive: true });

  // Create phases directory
  const phasesDir = join(planDir, "phases");
  mkdirSync(phasesDir, { recursive: true });
}

/**
 * Ensures global storage directory exists
 */
export function ensureStorage(): void {
  mkdirSync(GLOBAL_STORAGE_DIR, { recursive: true });
}

/**
 * Generates CLAUDE.md project context file for a plan
 */
export function generateProjectContext(plan: Plan): void {
  if (plan.storage_mode !== "local") return;

  const planDir = join(plan.project_path, ".plans", plan.id);
  const claudeMdPath = join(planDir, "CLAUDE.md");

  const phaseInfo = plan.is_phased && plan.phases
    ? `

## Current Phase

This plan is split into ${plan.phases.length} phases for manageable implementation:

${plan.phases.map((p, idx) => `${idx + 1}. **${p.name}** - ${p.status}`).join("\n")}

Current phase: ${plan.phases.find((p) => p.id === plan.current_phase_id)?.name || "Phase 1"}
`
    : "";

  const content = `# Plan: ${plan.name}

**Plan ID:** ${plan.id}
**Status:** ${plan.status}
**Created:** ${new Date(plan.created_at).toLocaleString()}
**Last Updated:** ${new Date(plan.updated_at).toLocaleString()}
${phaseInfo}

## Project Context

This directory contains a plan-bridge implementation plan for the project at:
\`${plan.project_path}\`

## Files

- \`plan.json\` - Full plan metadata including reviews and fix reports
- \`plan.md\` - Original plan content (markdown)
- \`CLAUDE.md\` - This file (auto-generated context)
${plan.is_phased ? `- \`phases/\` - Individual phase definitions\n` : ""}

## Usage

When implementing this plan:
1. Read \`plan.md\` for the full implementation requirements
2. Check \`plan.json\` for current status and review history
${plan.is_phased ? `3. Focus on the current phase only\n4. Mark phase complete before advancing\n` : ""}

## Reviews

${plan.reviews.length > 0
  ? plan.reviews.map((r, idx) => `### Review ${idx + 1} (${r.status})
- Timestamp: ${new Date(r.timestamp).toLocaleString()}
- Findings: ${r.findings.length}
${r.findings.length > 0 ? r.findings.map((f) => `  - ${f}`).join("\n") : "  - ‚úÖ Approved"}
`).join("\n")
  : "_No reviews yet_"}

## Fix Reports

${plan.fix_reports.length > 0
  ? plan.fix_reports.map((fr, idx) => `### Fix Report ${idx + 1}
- Timestamp: ${new Date(fr.timestamp).toLocaleString()}
- Fixes Applied: ${fr.fixes_applied.length}
${fr.fixes_applied.map((f) => `  - ${f}`).join("\n")}
`).join("\n")
  : "_No fix reports yet_"}

---
*This file is auto-generated by plan-bridge. Do not edit manually.*
`;

  writeFileSync(claudeMdPath, content, "utf-8");
  console.error(`[plan-bridge] üìÑ Generated CLAUDE.md at ${claudeMdPath}`);
}

/**
 * Saves a plan to storage (local or global based on storage_mode)
 */
export function savePlan(plan: Plan): void {
  if (plan.storage_mode === "local") {
    // Local storage mode
    ensureLocalStorage(plan.project_path, plan.id);
    const planDir = join(plan.project_path, ".plans", plan.id);

    // Save plan.json
    const planJsonPath = join(planDir, "plan.json");
    writeFileSync(planJsonPath, JSON.stringify(plan, null, 2), "utf-8");

    // Save plan.md (content only)
    const planMdPath = join(planDir, "plan.md");
    writeFileSync(planMdPath, plan.content, "utf-8");

    // Save phases if phased
    if (plan.is_phased && plan.phases) {
      for (const phase of plan.phases) {
        savePhase(plan, phase);
      }
    }

    // Generate CLAUDE.md
    generateProjectContext(plan);
  } else {
    // Global storage mode (backward compatibility)
    ensureStorage();
    const filePath = join(GLOBAL_STORAGE_DIR, `${plan.id}.json`);
    writeFileSync(filePath, JSON.stringify(plan, null, 2), "utf-8");
  }
}

/**
 * Saves a phase to local storage
 */
export function savePhase(plan: Plan, phase: Phase): void {
  if (plan.storage_mode !== "local") return;

  const phasesDir = join(plan.project_path, ".plans", plan.id, "phases");

  // Save phase JSON
  const phaseJsonPath = join(phasesDir, `phase-${phase.phase_number}.json`);
  writeFileSync(phaseJsonPath, JSON.stringify(phase, null, 2), "utf-8");

  // Save phase markdown
  const phaseMdPath = join(phasesDir, `phase-${phase.phase_number}.md`);
  writeFileSync(phaseMdPath, phase.content, "utf-8");
}

/**
 * Loads a plan by ID, checking local storage first, then global
 */
export function loadPlan(id: string, projectPath?: string): Plan | null {
  // Try local storage first if project path provided
  if (projectPath) {
    const localPlanPath = join(projectPath, ".plans", id, "plan.json");
    if (existsSync(localPlanPath)) {
      const data = readFileSync(localPlanPath, "utf-8");
      return JSON.parse(data) as Plan;
    }
  }

  // Fallback to global storage
  const globalPlanPath = join(GLOBAL_STORAGE_DIR, `${id}.json`);
  if (existsSync(globalPlanPath)) {
    const data = readFileSync(globalPlanPath, "utf-8");
    return JSON.parse(data) as Plan;
  }

  return null;
}

/**
 * Loads a specific phase from local storage
 */
export function loadPhase(planId: string, phaseId: string, projectPath: string): Phase | null {
  const plan = loadPlan(planId, projectPath);
  if (!plan || !plan.is_phased || !plan.phases) return null;

  return plan.phases.find((p) => p.id === phaseId) || null;
}

/**
 * Lists all plans with optional filters
 */
export function listPlans(status?: PlanStatus, projectPath?: string, storageMode?: "global" | "local"): Plan[] {
  const plans: Plan[] = [];

  // Load from global storage if not explicitly excluding it
  if (storageMode !== "local") {
    ensureStorage();
    if (existsSync(GLOBAL_STORAGE_DIR)) {
      const files = readdirSync(GLOBAL_STORAGE_DIR).filter((f) => f.endsWith(".json"));
      for (const file of files) {
        try {
          const data = readFileSync(join(GLOBAL_STORAGE_DIR, file), "utf-8");
          const plan = JSON.parse(data) as Plan;
          // Ensure backward compatibility - set storage_mode if missing
          if (!plan.storage_mode) {
            plan.storage_mode = "global";
          }
          if (!plan.is_phased) {
            plan.is_phased = false;
          }
          plans.push(plan);
        } catch (err) {
          console.error(`[plan-bridge] ‚ö†Ô∏è  Failed to load plan: ${file}`, err);
        }
      }
    }
  }

  // Load from local storage if not explicitly excluding it
  if (storageMode !== "global" && projectPath) {
    const plansDir = join(projectPath, ".plans");
    if (existsSync(plansDir)) {
      const planDirs = readdirSync(plansDir, { withFileTypes: true })
        .filter((d) => d.isDirectory())
        .map((d) => d.name);

      for (const planDir of planDirs) {
        try {
          const planJsonPath = join(plansDir, planDir, "plan.json");
          if (existsSync(planJsonPath)) {
            const data = readFileSync(planJsonPath, "utf-8");
            const plan = JSON.parse(data) as Plan;
            plans.push(plan);
          }
        } catch (err) {
          console.error(`[plan-bridge] ‚ö†Ô∏è  Failed to load local plan: ${planDir}`, err);
        }
      }
    }
  }

  // Apply filters
  let filtered = plans;
  if (status) {
    filtered = filtered.filter((p) => p.status === status);
  }
  if (projectPath) {
    filtered = filtered.filter((p) => p.project_path === projectPath);
  }

  // Sort by updated_at descending
  return filtered.sort(
    (a, b) => new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()
  );
}

/**
 * Loads the latest plan with optional filters
 */
export function loadLatestPlan(status?: PlanStatus, projectPath?: string): Plan | null {
  const plans = listPlans(status, projectPath);
  return plans.length > 0 ? plans[0] : null;
}

/**
 * Migrates a global plan to local storage
 */
export function migratePlanToLocal(planId: string, targetProjectPath: string): Plan | null {
  const plan = loadPlan(planId);
  if (!plan) return null;

  if (plan.storage_mode === "local") {
    console.error(`[plan-bridge] ‚ö†Ô∏è  Plan ${planId} is already in local storage`);
    return plan;
  }

  // Update plan metadata
  plan.storage_mode = "local";
  plan.project_path = targetProjectPath;
  plan.updated_at = new Date().toISOString();

  // Save to local storage
  savePlan(plan);

  // Optionally remove from global storage
  const globalPath = join(GLOBAL_STORAGE_DIR, `${planId}.json`);
  if (existsSync(globalPath)) {
    rmSync(globalPath);
    console.error(`[plan-bridge] üîÑ Migrated plan ${planId} from global to local storage`);
  }

  return plan;
}
